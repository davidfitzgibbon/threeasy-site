---	
import Example from '../../layouts/Example.astro';
---

<Example title="Wriggloop">
  <style>
    @import url("https://fonts.googleapis.com/css?family=Raleway:400,400i,700");

    body,
    html {
      margin: 0;
      height: 100vh;
    }

    canvas {
      width: 100%;
      height: 100%;
    }

    h1 {
      position: absolute;
      bottom: 1em;
      left: 0;
      right: 0;
      text-align: center;
      z-index: 1;
      font-size: 20px;
      font-family: Raleway, sans-serif;
      font-weight: normal;
    }

    a {
      color: dodgerblue;
    }
  </style>
  <h1>
    Immitation of
    <a target="_blank" href="https://junkiyoshi.com/openframeworks20210427/">Twisting by JUNKIYOSHI</a>
  </h1>
  <script type="module">
    import Threeasy from "threeasy";
    import * as THREE from "three";
    import { OutlineEffect } from "three/examples/jsm/effects/OutlineEffect.js";
    import { makeNoise4D } from "https://cdn.skypack.dev/open-simplex-noise";
    const noise4D = makeNoise4D(Date.now());

    const app = new Threeasy(THREE, { light: false });
    app.scene.background = new THREE.Color(0xffffff);
    app.camera.position.x = -0;
    app.camera.position.y = 0;
    app.camera.position.z = 3;
    app.renderer.toneMapping = THREE.NoToneMapping;

    let colorCount = 6;
    let groupCount = 128;
    let throttle = 0.4;
    let angleOfRotation = Math.PI * 5;
    let amplitude = 0.75;
    let materials = [];
    let curves = [];
    let geometries = [];
    let meshes = [];

    // createGroup
    let basicGroup = new THREE.Group();
    for (let i = 0; i < colorCount; i++) {
      const angleDeg = (360 / colorCount) * i;
      const angleRad = (angleDeg / 360) * Math.PI * 2;
      const radius = 0.1;

      const material = new THREE.MeshBasicMaterial({
        color: `hsl(${angleDeg},60%,50%)`
      });
      materials.push(material);

      const mesh = new THREE.Object3D();
      mesh.position.x = Math.cos(angleRad) * radius;
      mesh.position.z = Math.sin(angleRad) * radius;
      basicGroup.add(mesh);
    }

    // duplicate and place
    let groups = [];
    for (let i = 0; i < groupCount; i++) {
      const group = basicGroup.clone();

      const angleDeg = (360 / groupCount) * i;
      const angleRad = (angleDeg / 360) * Math.PI * 2;
      const radius = 1;

      //  ROTATION
      group.rotation.z = angleRad;
      group.dir = new THREE.Vector3(0, Math.PI, 0);
      group.dir.normalize();

      // POSITION
      group.position.x = Math.cos(angleRad) * radius;
      group.position.y = Math.sin(angleRad) * radius;

      group.currentAngle = 0;

      groups.push(group);
      // scene.add(group);
    }

    // add tubes
    createGeometries();

    app.animator.add(() => {
      groups.forEach((group) => {
        let noise = noise4D(
          group.position.x * amplitude,
          group.position.y * amplitude,
          group.position.z * amplitude,
          app.clock.getElapsedTime()
        );
        const targetAngle = noise * throttle * angleOfRotation;
        const angleOfMovement = targetAngle - group.currentAngle;

        group.rotateOnAxis(group.dir, angleOfMovement);
        group.currentAngle = targetAngle;
      });
      updateGeometries();
    });

    let effect = new OutlineEffect(app.renderer);
    app.render = () => {
      effect.render(app.scene, app.camera);
    };

    function createGeometries() {
      for (let i = 0; i < colorCount; i++) {
        // get points
        const pointArray = [];
        groups.forEach((group) => {
          const point = group.children[i];
          pointArray.push(point.getWorldPosition(new THREE.Vector3()));
        });

        // create curve
        curves.push(new THREE.CatmullRomCurve3(pointArray, true));

        // create geometry
        geometries.push(new THREE.TubeGeometry(curves[i], 128, 0.05, 16));

        // mesh
        meshes.push(new THREE.Mesh(geometries[i], materials[i]));

        app.scene.add(meshes[i]);
      }
    }
    function updateGeometries() {
      for (let i = 0; i < colorCount; i++) {
        // get points
        const pointArray = [];
        groups.forEach((group) => {
          const point = group.children[i];
          pointArray.push(point.getWorldPosition(new THREE.Vector3()));
        });

        // create curve
        curves[i] = new THREE.CatmullRomCurve3(pointArray, true);

        // create geometry
        geometries[i] = new THREE.TubeGeometry(curves[i], 128, 0.05, 16);

        // mesh
        meshes[i].geometry = geometries[i];

        meshes[i].geometry.verticesNeedUpdate = true;
        meshes[i].geometry.dynamic = true;
      }
    }


  </script>
</Example>