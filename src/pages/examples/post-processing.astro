---	
import Example from '../../layouts/Example.astro';
---
<Example title="Post Processing">
  <script type="module">
    import * as THREE from "three";
    import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";
    import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass.js";
    import { ShaderPass } from "three/examples/jsm/postprocessing/ShaderPass.js";
    import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
    import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer.js";
    import { LuminosityShader } from "three/examples/jsm/shaders/LuminosityShader.js";
    import { SobelOperatorShader } from "three/examples/jsm/shaders/SobelOperatorShader.js";

    import Threeasy from "threeasy";

    const fragment = `
      uniform float amount;
      uniform sampler2D tDiffuse;
      varying vec2 vUv;

      float random (vec2 st, float seed) {
        const float a = 12.9898;
        const float b = 78.233;
        const float c = 43758.543123;
        return fract(sin(dot(st, vec2(a, b)) + seed) * c );
      }

      void main() {
        vec4 color = texture2D( tDiffuse, vUv );
        vec3 colorFlip = 1.0 - color.rgb;

        gl_FragColor = vec4( colorFlip, 1);
      }
    `;

    const vertex = `
      varying vec2 vUv;

      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
      }
    `;

    const racecarFile = "/examples/models/f1.glb";

    const app = new Threeasy(THREE, {
      preload: {
        car: racecarFile
      },
      GLTFLoader
    });

    let composer, effectSobel;

    function resetColors(obj) {
      var greyMaterial = new THREE.MeshStandardMaterial();
      obj.traverse((child) => {
        if (child.type === "Mesh") {
          child.material = greyMaterial;
        }
      });
      return obj;
    }

    app.camera.position.set(0, 0, 5);

    new OrbitControls(app.camera, app.renderer.domElement);

    var lightAmbient = new THREE.AmbientLight(0xffffff, 0.7, 100);
    app.scene.add(lightAmbient);

    var lightDirectional = new THREE.DirectionalLight(0xffffff, 1, 100);
    lightDirectional.position.set(-3, 5, -3); //default; light shining from top
    app.scene.add(lightDirectional);

    // RACECAR
    app.postload(() => {
      var countX = 8,
        countY = 4,
        distX = 1.3,
        distY = 1.5;

      var model = resetColors(app.car);

      for (let x = 0; x <= countX; x++) {
        for (let y = 0; y <= countY; y++) {
          let racecar = model.clone();
          racecar.scale.set(0.005, 0.005, 0.005);
          racecar.rotateY(Math.PI / 2);
          racecar.position.x = -(countX * distX) / 2 + distX * x - 0.2;
          racecar.position.y = -(countY * distY) / 2 + distY * y;
          app.scene.add(racecar);
        }
      }

      // postprocessing

      composer = new EffectComposer(app.renderer);
      var renderPass = new RenderPass(app.scene, app.camera);
      composer.addPass(renderPass);

      // color to grayscale conversion

      var effectGrayScale = new ShaderPass(LuminosityShader);
      composer.addPass(effectGrayScale);

      // you might want to use a gaussian blur filter before
      // the next pass to improve the result of the Sobel operator

      // Sobel operator
      effectSobel = new ShaderPass(SobelOperatorShader);
      effectSobel.uniforms["resolution"].value.x =
        window.innerWidth * window.devicePixelRatio;
      effectSobel.uniforms["resolution"].value.y =
        window.innerHeight * window.devicePixelRatio;
      composer.addPass(effectSobel);

      let colorFlipShader = {
        uniforms: {
          tDiffuse: { value: null },
          amount: { value: 1.0 }
        },
        vertexShader: vertex,
        fragmentShader: fragment
      };
      let shader = new ShaderPass(colorFlipShader);
      composer.addPass(shader);

      app.render = () => composer.render();

      app.resize = () => {
        app.camera.aspect = window.innerWidth / window.innerHeight;
        app.camera.updateProjectionMatrix();

        app.renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);

        effectSobel.uniforms["resolution"].value.x =
          window.innerWidth * window.devicePixelRatio;
        effectSobel.uniforms["resolution"].value.y =
          window.innerHeight * window.devicePixelRatio;
      };
    });

  </script>
</Example>